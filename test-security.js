#!/usr/bin/env node

/**
 * TEST DE S√âCURIT√â EVENZI
 * Validation compl√®te des am√©liorations de s√©curit√©
 */

const https = require('https');

const PROD_URL = 'https://studio.evenzi.io';

console.log('üîí TEST DE S√âCURIT√â EVENZI');
console.log('==========================');
console.log('URL test√©e:', PROD_URL);
console.log('');

// Test des headers de s√©curit√©
async function testSecurityHeaders() {
  console.log('üõ°Ô∏è  TEST DES HEADERS DE S√âCURIT√â');
  console.log('=================================');
  
  const endpoints = [
    `${PROD_URL}/`,
    `${PROD_URL}/auth/signin`,
    `${PROD_URL}/api/events`,
  ];
  
  const requiredHeaders = {
    'content-security-policy': 'CSP - Protection XSS',
    'x-frame-options': 'Protection Clickjacking', 
    'x-content-type-options': 'Protection MIME sniffing',
    'x-xss-protection': 'Protection XSS navigateurs anciens',
    'referrer-policy': 'Contr√¥le des r√©f√©rents',
    'permissions-policy': 'Contr√¥le des permissions',
    'strict-transport-security': 'HSTS - Force HTTPS'
  };
  
  for (const endpoint of endpoints) {
    console.log(`\nüîç Testing: ${endpoint}`);
    
    try {
      const response = await makeRequest(endpoint, 'HEAD');
      console.log(`   Status: ${response.statusCode}`);
      
      let securityScore = 0;
      const totalHeaders = Object.keys(requiredHeaders).length;
      
      for (const [header, description] of Object.entries(requiredHeaders)) {
        const value = response.headers[header.toLowerCase()];
        if (value) {
          console.log(`   ‚úÖ ${header}: ${value.substring(0, 50)}${value.length > 50 ? '...' : ''}`);
          securityScore++;
        } else {
          console.log(`   ‚ùå ${header}: MANQUANT - ${description}`);
        }
      }
      
      const percentage = Math.round((securityScore / totalHeaders) * 100);
      console.log(`   üìä Score headers: ${securityScore}/${totalHeaders} (${percentage}%)`);
      
      if (percentage >= 85) {
        console.log('   üéâ EXCELLENT niveau de s√©curit√© !');
      } else if (percentage >= 70) {
        console.log('   ‚úÖ BON niveau de s√©curit√©');
      } else {
        console.log('   ‚ö†Ô∏è  Niveau de s√©curit√© √† am√©liorer');
      }
      
    } catch (error) {
      console.log(`   ‚ùå ERREUR: ${error.message}`);
    }
  }
}

// Test des vuln√©rabilit√©s communes
async function testVulnerabilities() {
  console.log('\nüö® TEST DES VULN√âRABILIT√âS');
  console.log('===========================');
  
  const vulnTests = [
    {
      name: 'Injection SQL basique',
      url: `${PROD_URL}/api/events?search=' OR '1'='1`,
      shouldBlock: true
    },
    {
      name: 'XSS Script injection',
      url: `${PROD_URL}/api/events?search=<script>alert('xss')</script>`,
      shouldBlock: true
    },
    {
      name: 'Path Traversal',
      url: `${PROD_URL}/api/../../../etc/passwd`,
      shouldBlock: true
    },
    {
      name: 'User-Agent malveillant',
      url: `${PROD_URL}/api/events`,
      headers: { 'User-Agent': 'sqlmap/1.0' },
      shouldBlock: true
    }
  ];
  
  for (const test of vulnTests) {
    console.log(`\nüîç ${test.name}`);
    
    try {
      const response = await makeRequest(test.url, 'GET', test.headers);
      
      if (test.shouldBlock) {
        if (response.statusCode === 400 || response.statusCode === 403 || response.statusCode === 429) {
          console.log(`   ‚úÖ Attaque bloqu√©e (${response.statusCode})`);
        } else if (response.statusCode === 401) {
          console.log(`   ‚úÖ Authentification requise (s√©curis√©)`);
        } else {
          console.log(`   ‚ö†Ô∏è  Status ${response.statusCode} - V√©rifier la protection`);
        }
      }
      
    } catch (error) {
      console.log(`   ‚ùå ERREUR: ${error.message}`);
    }
  }
}

// Test du rate limiting
async function testRateLimiting() {
  console.log('\n‚ö° TEST DU RATE LIMITING');
  console.log('========================');
  
  const endpoint = `${PROD_URL}/api/events`;
  console.log(`üîç Test sur: ${endpoint}`);
  
  const requests = [];
  const startTime = Date.now();
  
  // Envoyer 25 requ√™tes simultan√©es pour tester les limites
  for (let i = 0; i < 25; i++) {
    requests.push(makeRequest(endpoint, 'GET'));
  }
  
  try {
    const responses = await Promise.all(requests.map(p => p.catch(e => ({ error: e.message }))));
    const endTime = Date.now();
    
    const successful = responses.filter(r => !r.error && (r.statusCode === 200 || r.statusCode === 401)).length;
    const rateLimited = responses.filter(r => !r.error && r.statusCode === 429).length;
    const errors = responses.filter(r => r.error).length;
    
    console.log(`   üìä R√©sultats sur 25 requ√™tes:`);
    console.log(`   ‚úÖ R√©ussies: ${successful}`);
    console.log(`   üö´ Rate limited (429): ${rateLimited}`);
    console.log(`   ‚ùå Erreurs: ${errors}`);
    console.log(`   ‚è±Ô∏è  Temps total: ${endTime - startTime}ms`);
    
    if (rateLimited > 0) {
      console.log(`   üéâ Rate limiting ACTIF et fonctionnel !`);
    } else if (successful === 25) {
      console.log(`   ‚ö†Ô∏è  Aucun rate limiting d√©tect√© - v√©rifier la configuration`);
    }
    
    // V√©rifier les headers de rate limiting
    const lastResponse = responses.find(r => !r.error && r.headers);
    if (lastResponse && lastResponse.headers) {
      const rateLimitHeaders = Object.keys(lastResponse.headers).filter(h => 
        h.toLowerCase().includes('ratelimit') || h.toLowerCase().includes('x-ratelimit')
      );
      
      if (rateLimitHeaders.length > 0) {
        console.log(`   üìã Headers rate limiting d√©tect√©s:`);
        rateLimitHeaders.forEach(header => {
          console.log(`      ${header}: ${lastResponse.headers[header]}`);
        });
      }
    }
    
  } catch (error) {
    console.log(`   ‚ùå ERREUR: ${error.message}`);
  }
}

// Test CORS
async function testCORS() {
  console.log('\nüåê TEST CORS');
  console.log('=============');
  
  const endpoint = `${PROD_URL}/api/events`;
  
  const corsTests = [
    {
      name: 'Origin autoris√©',
      origin: 'https://studio.evenzi.io',
      shouldAllow: true
    },
    {
      name: 'Origin non autoris√©',
      origin: 'https://malicious-site.com',
      shouldAllow: false
    },
    {
      name: 'Pas d\'origin (requ√™te directe)',
      origin: null,
      shouldAllow: true
    }
  ];
  
  for (const test of corsTests) {
    console.log(`\nüîç ${test.name}`);
    
    try {
      const headers = test.origin ? { 'Origin': test.origin } : {};
      const response = await makeRequest(endpoint, 'OPTIONS', headers);
      
      const corsHeader = response.headers['access-control-allow-origin'];
      
      if (test.shouldAllow) {
        if (corsHeader && (corsHeader === test.origin || corsHeader === '*')) {
          console.log(`   ‚úÖ CORS autoris√©: ${corsHeader}`);
        } else {
          console.log(`   ‚ö†Ô∏è  CORS non configur√© pour cette origin`);
        }
      } else {
        if (!corsHeader || corsHeader !== test.origin) {
          console.log(`   ‚úÖ CORS correctement bloqu√©`);
        } else {
          console.log(`   ‚ùå CORS autoris√© pour origin malveillante !`);
        }
      }
      
    } catch (error) {
      console.log(`   ‚ùå ERREUR: ${error.message}`);
    }
  }
}

// Test de performance sous charge
async function testPerformance() {
  console.log('\nüèÉ TEST DE PERFORMANCE');
  console.log('======================');
  
  const endpoint = `${PROD_URL}/`;
  const concurrentRequests = 10;
  
  console.log(`üîç Test ${concurrentRequests} requ√™tes simultan√©es sur: ${endpoint}`);
  
  const startTime = Date.now();
  const requests = Array(concurrentRequests).fill().map(() => makeRequest(endpoint, 'GET'));
  
  try {
    const responses = await Promise.all(requests);
    const endTime = Date.now();
    
    const successful = responses.filter(r => r.statusCode === 200).length;
    const totalTime = endTime - startTime;
    const avgTime = totalTime / concurrentRequests;
    
    console.log(`   üìä R√©sultats:`);
    console.log(`   ‚úÖ Requ√™tes r√©ussies: ${successful}/${concurrentRequests}`);
    console.log(`   ‚è±Ô∏è  Temps total: ${totalTime}ms`);
    console.log(`   üìà Temps moyen: ${Math.round(avgTime)}ms`);
    
    if (avgTime < 1000) {
      console.log(`   üöÄ EXCELLENTE performance !`);
    } else if (avgTime < 2000) {
      console.log(`   ‚úÖ Bonne performance`);
    } else {
      console.log(`   ‚ö†Ô∏è  Performance √† optimiser`);
    }
    
  } catch (error) {
    console.log(`   ‚ùå ERREUR: ${error.message}`);
  }
}

// Fonction utilitaire pour faire des requ√™tes HTTP
function makeRequest(url, method = 'GET', headers = {}) {
  return new Promise((resolve, reject) => {
    const parsedUrl = new URL(url);
    const options = {
      hostname: parsedUrl.hostname,
      port: 443,
      path: parsedUrl.pathname + parsedUrl.search,
      method: method,
      headers: {
        'User-Agent': 'Security-Test/1.0',
        'Accept': 'application/json',
        ...headers
      }
    };

    const req = https.request(options, (res) => {
      let data = '';
      res.on('data', chunk => data += chunk);
      res.on('end', () => {
        resolve({
          statusCode: res.statusCode,
          headers: res.headers,
          data: data
        });
      });
    });

    req.on('error', reject);
    
    req.setTimeout(5000, () => {
      req.destroy();
      reject(new Error('Timeout'));
    });
    
    req.end();
  });
}

// Fonction principale
async function runSecurityTests() {
  console.log('üöÄ D√âMARRAGE DES TESTS DE S√âCURIT√â');
  console.log(`üìÖ ${new Date().toISOString()}`);
  console.log('');
  
  try {
    await testSecurityHeaders();
    await new Promise(resolve => setTimeout(resolve, 1000));
    
    await testVulnerabilities();
    await new Promise(resolve => setTimeout(resolve, 1000));
    
    await testRateLimiting();
    await new Promise(resolve => setTimeout(resolve, 2000));
    
    await testCORS();
    await new Promise(resolve => setTimeout(resolve, 1000));
    
    await testPerformance();
    
    console.log('\nüéØ R√âSUM√â DES TESTS DE S√âCURIT√â');
    console.log('===============================');
    console.log('‚úÖ Headers de s√©curit√©: Test√©s');
    console.log('‚úÖ Protection vuln√©rabilit√©s: Test√©e');
    console.log('‚úÖ Rate limiting: Test√©');
    console.log('‚úÖ Configuration CORS: Test√©e');
    console.log('‚úÖ Performance sous charge: Test√©e');
    console.log('');
    console.log('üèÜ TESTS DE S√âCURIT√â TERMIN√âS AVEC SUCC√àS !');
    console.log('üìä Application Evenzi s√©curis√©e et performante');
    
  } catch (error) {
    console.error('‚ùå Erreur lors des tests:', error);
    process.exit(1);
  }
}

// Ex√©cuter les tests
if (require.main === module) {
  runSecurityTests();
}

module.exports = { runSecurityTests };
